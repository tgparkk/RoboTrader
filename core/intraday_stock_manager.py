"""
ì¥ì¤‘ ì¢…ëª© ì„ ì • ë° ê³¼ê±° ë¶„ë´‰ ë°ì´í„° ê´€ë¦¬
"""
import asyncio
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Tuple
import pandas as pd
from dataclasses import dataclass, field
import threading
from collections import defaultdict

from utils.logger import setup_logger
from utils.korean_time import now_kst, is_market_open
from api.kis_chart_api import get_inquire_time_itemchartprice, get_inquire_time_dailychartprice


logger = setup_logger(__name__)


@dataclass
class StockMinuteData:
    """ì¢…ëª©ë³„ ë¶„ë´‰ ë°ì´í„° í´ë˜ìŠ¤"""
    stock_code: str
    stock_name: str
    selected_time: datetime
    historical_data: pd.DataFrame = field(default_factory=pd.DataFrame)
    realtime_data: pd.DataFrame = field(default_factory=pd.DataFrame)
    last_update: Optional[datetime] = None
    data_complete: bool = False
    
    def __post_init__(self):
        """ì´ˆê¸°í™” í›„ ì²˜ë¦¬"""
        if self.last_update is None:
            self.last_update = self.selected_time


class IntradayStockManager:
    """
    ì¥ì¤‘ ì¢…ëª© ì„ ì • ë° ê³¼ê±° ë¶„ë´‰ ë°ì´í„° ê´€ë¦¬ í´ë˜ìŠ¤
    
    ì£¼ìš” ê¸°ëŠ¥:
    1. ì¡°ê±´ê²€ìƒ‰ìœ¼ë¡œ ì„ ì •ëœ ì¢…ëª©ì˜ ê³¼ê±° ë¶„ë´‰ ë°ì´í„° ìˆ˜ì§‘
    2. ë©”ëª¨ë¦¬ì—ì„œ íš¨ìœ¨ì ì¸ ë°ì´í„° ê´€ë¦¬
    3. ì‹¤ì‹œê°„ ë¶„ë´‰ ë°ì´í„° ì—…ë°ì´íŠ¸
    4. ë°ì´í„° ë¶„ì„ì„ ìœ„í•œ í¸ì˜ í•¨ìˆ˜ ì œê³µ
    """
    
    def __init__(self, api_manager):
        """
        ì´ˆê¸°í™”
        
        Args:
            api_manager: KIS API ë§¤ë‹ˆì € ì¸ìŠ¤í„´ìŠ¤
        """
        self.api_manager = api_manager
        self.logger = setup_logger(__name__)
        
        # ë©”ëª¨ë¦¬ ì €ì¥ì†Œ
        self.selected_stocks: Dict[str, StockMinuteData] = {}  # stock_code -> StockMinuteData
        self.selection_history: List[Dict[str, Any]] = []  # ì„ ì • ì´ë ¥
        
        # ì„¤ì •
        self.market_open_time = "090000"  # ì¥ ì‹œì‘ ì‹œê°„
        self.max_stocks = 50  # ìµœëŒ€ ê´€ë¦¬ ì¢…ëª© ìˆ˜
        
        # ë™ê¸°í™”
        self._lock = threading.RLock()
        
        self.logger.info("ğŸ¯ ì¥ì¤‘ ì¢…ëª© ê´€ë¦¬ì ì´ˆê¸°í™” ì™„ë£Œ")
    
    def add_selected_stock(self, stock_code: str, stock_name: str, 
                          selection_reason: str = "") -> bool:
        """
        ì¡°ê±´ê²€ìƒ‰ìœ¼ë¡œ ì„ ì •ëœ ì¢…ëª© ì¶”ê°€
        
        Args:
            stock_code: ì¢…ëª©ì½”ë“œ
            stock_name: ì¢…ëª©ëª…
            selection_reason: ì„ ì • ì‚¬ìœ 
            
        Returns:
            bool: ì¶”ê°€ ì„±ê³µ ì—¬ë¶€
        """
        try:
            with self._lock:
                current_time = now_kst()
                
                # ì´ë¯¸ ì¡´ì¬í•˜ëŠ” ì¢…ëª©ì¸ì§€ í™•ì¸
                if stock_code in self.selected_stocks:
                    self.logger.debug(f"ğŸ“Š {stock_code}({stock_name}): ì´ë¯¸ ê´€ë¦¬ ì¤‘ì¸ ì¢…ëª©")
                    return True
                
                # ìµœëŒ€ ê´€ë¦¬ ì¢…ëª© ìˆ˜ ì²´í¬
                if len(self.selected_stocks) >= self.max_stocks:
                    self.logger.warning(f"âš ï¸ ìµœëŒ€ ê´€ë¦¬ ì¢…ëª© ìˆ˜({self.max_stocks})ì— ë„ë‹¬. ì¶”ê°€ ë¶ˆê°€")
                    return False
                
                # ì¥ ì‹œê°„ ì²´í¬
                if not is_market_open():
                    self.logger.warning(f"âš ï¸ ì¥ ì‹œê°„ì´ ì•„ë‹˜. {stock_code} ì¶”ê°€ ë³´ë¥˜")
                    return False
                
                # ì¢…ëª© ë°ì´í„° ê°ì²´ ìƒì„±
                stock_data = StockMinuteData(
                    stock_code=stock_code,
                    stock_name=stock_name,
                    selected_time=current_time
                )
                
                # ë©”ëª¨ë¦¬ì— ì¶”ê°€
                self.selected_stocks[stock_code] = stock_data
                
                # ì„ ì • ì´ë ¥ ê¸°ë¡
                self.selection_history.append({
                    'stock_code': stock_code,
                    'stock_name': stock_name,
                    'selected_time': current_time,
                    'selection_reason': selection_reason,
                    'market_time': current_time.strftime('%H:%M:%S')
                })
                
                self.logger.info(f"âœ… {stock_code}({stock_name}) ì¥ì¤‘ ì„ ì • ì™„ë£Œ - "
                               f"ì‹œê°„: {current_time.strftime('%H:%M:%S')}")
                
                # ë¹„ë™ê¸°ë¡œ ê³¼ê±° ë°ì´í„° ìˆ˜ì§‘ ì‹œì‘
                asyncio.create_task(self._collect_historical_data(stock_code))
                
                return True
                
        except Exception as e:
            self.logger.error(f"âŒ {stock_code} ì¢…ëª© ì¶”ê°€ ì˜¤ë¥˜: {e}")
            return False
    
    async def _collect_historical_data(self, stock_code: str) -> bool:
        """
        ì„ ì • ì‹œì  ì´ì „ì˜ ê³¼ê±° ë¶„ë´‰ ë°ì´í„° ìˆ˜ì§‘
        
        Args:
            stock_code: ì¢…ëª©ì½”ë“œ
            
        Returns:
            bool: ìˆ˜ì§‘ ì„±ê³µ ì—¬ë¶€
        """
        try:
            with self._lock:
                if stock_code not in self.selected_stocks:
                    return False
                    
                stock_data = self.selected_stocks[stock_code]
                selected_time = stock_data.selected_time
            
            self.logger.debug(f"ğŸ“ˆ {stock_code} ê³¼ê±° ë¶„ë´‰ ë°ì´í„° ìˆ˜ì§‘ ì‹œì‘")
            
            # ì„ ì • ì‹œê°„ê¹Œì§€ì˜ ë‹¹ì¼ ë¶„ë´‰ ë°ì´í„° ì¡°íšŒ
            target_hour = selected_time.strftime("%H%M%S")
            
            # ë‹¹ì¼ë¶„ë´‰ì¡°íšŒ API ì‚¬ìš© (ìµœëŒ€ 30ê±´)
            result = get_inquire_time_itemchartprice(
                stock_code=stock_code,
                input_hour=target_hour,
                past_data_yn="Y"
            )
            
            if result is None:
                self.logger.error(f"âŒ {stock_code} ê³¼ê±° ë¶„ë´‰ ë°ì´í„° ì¡°íšŒ ì‹¤íŒ¨")
                return False
            
            summary_df, chart_df = result
            
            if chart_df.empty:
                self.logger.warning(f"âš ï¸ {stock_code} ê³¼ê±° ë¶„ë´‰ ë°ì´í„° ì—†ìŒ")
                # ë¹ˆ DataFrameì´ë¼ë„ ì €ì¥
                with self._lock:
                    if stock_code in self.selected_stocks:
                        self.selected_stocks[stock_code].historical_data = pd.DataFrame()
                        self.selected_stocks[stock_code].data_complete = True
                return True
            
            # ì„ ì • ì‹œì  ì´ì „ ë°ì´í„°ë§Œ í•„í„°ë§
            if 'datetime' in chart_df.columns:
                # ì„ ì • ì‹œê°„ ì´ì „ ë°ì´í„°ë§Œ ì„ íƒ
                historical_data = chart_df[chart_df['datetime'] <= selected_time].copy()
            else:
                # datetime ì»¬ëŸ¼ì´ ì—†ìœ¼ë©´ ì „ì²´ ë°ì´í„° ì‚¬ìš©
                historical_data = chart_df.copy()
            
            # ë©”ëª¨ë¦¬ì— ì €ì¥
            with self._lock:
                if stock_code in self.selected_stocks:
                    self.selected_stocks[stock_code].historical_data = historical_data
                    self.selected_stocks[stock_code].data_complete = True
                    self.selected_stocks[stock_code].last_update = now_kst()
            
            # ë°ì´í„° ë¶„ì„
            data_count = len(historical_data)
            if data_count > 0:
                start_time = historical_data.iloc[0].get('time', 'N/A') if 'time' in historical_data.columns else 'N/A'
                end_time = historical_data.iloc[-1].get('time', 'N/A') if 'time' in historical_data.columns else 'N/A'
                
                self.logger.info(f"âœ… {stock_code} ê³¼ê±° ë¶„ë´‰ ìˆ˜ì§‘ ì™„ë£Œ: {data_count}ê±´ "
                               f"({start_time} ~ {end_time})")
            else:
                self.logger.info(f"â„¹ï¸ {stock_code} ì„ ì • ì‹œì  ì´ì „ ë¶„ë´‰ ë°ì´í„° ì—†ìŒ")
            
            return True
            
        except Exception as e:
            self.logger.error(f"âŒ {stock_code} ê³¼ê±° ë¶„ë´‰ ë°ì´í„° ìˆ˜ì§‘ ì˜¤ë¥˜: {e}")
            return False
    
    async def update_realtime_data(self, stock_code: str) -> bool:
        """
        ì‹¤ì‹œê°„ ë¶„ë´‰ ë°ì´í„° ì—…ë°ì´íŠ¸
        
        Args:
            stock_code: ì¢…ëª©ì½”ë“œ
            
        Returns:
            bool: ì—…ë°ì´íŠ¸ ì„±ê³µ ì—¬ë¶€
        """
        try:
            with self._lock:
                if stock_code not in self.selected_stocks:
                    return False
                    
                stock_data = self.selected_stocks[stock_code]
                selected_time = stock_data.selected_time
            
            # í˜„ì¬ ì‹œê°„ê¹Œì§€ì˜ ë‹¹ì¼ ë¶„ë´‰ ë°ì´í„° ì¡°íšŒ
            current_time = now_kst()
            target_hour = current_time.strftime("%H%M%S")
            
            result = get_inquire_time_itemchartprice(
                stock_code=stock_code,
                input_hour=target_hour,
                past_data_yn="Y"
            )
            
            if result is None:
                return False
            
            summary_df, chart_df = result
            
            if chart_df.empty:
                return True
            
            # ì„ ì • ì‹œì  ì´í›„ ë°ì´í„°ë§Œ ì¶”ì¶œ (ì‹¤ì‹œê°„ ë°ì´í„°)
            if 'datetime' in chart_df.columns:
                realtime_data = chart_df[chart_df['datetime'] > selected_time].copy()
            else:
                # datetime ì»¬ëŸ¼ì´ ì—†ìœ¼ë©´ ì‹œê°„ ë¹„êµë¡œ ëŒ€ì²´
                realtime_data = chart_df.copy()
            
            # ë©”ëª¨ë¦¬ì— ì—…ë°ì´íŠ¸
            with self._lock:
                if stock_code in self.selected_stocks:
                    self.selected_stocks[stock_code].realtime_data = realtime_data
                    self.selected_stocks[stock_code].last_update = current_time
            
            self.logger.debug(f"ğŸ“Š {stock_code} ì‹¤ì‹œê°„ ë¶„ë´‰ ì—…ë°ì´íŠ¸: {len(realtime_data)}ê±´")
            return True
            
        except Exception as e:
            self.logger.error(f"âŒ {stock_code} ì‹¤ì‹œê°„ ë¶„ë´‰ ì—…ë°ì´íŠ¸ ì˜¤ë¥˜: {e}")
            return False
    
    def get_stock_data(self, stock_code: str) -> Optional[StockMinuteData]:
        """
        ì¢…ëª©ì˜ ì „ì²´ ë°ì´í„° ì¡°íšŒ
        
        Args:
            stock_code: ì¢…ëª©ì½”ë“œ
            
        Returns:
            StockMinuteData: ì¢…ëª© ë°ì´í„° ë˜ëŠ” None
        """
        with self._lock:
            return self.selected_stocks.get(stock_code)
    
    def get_combined_chart_data(self, stock_code: str) -> Optional[pd.DataFrame]:
        """
        ì¢…ëª©ì˜ ê³¼ê±° + ì‹¤ì‹œê°„ ê²°í•© ì°¨íŠ¸ ë°ì´í„° ì¡°íšŒ
        
        Args:
            stock_code: ì¢…ëª©ì½”ë“œ
            
        Returns:
            pd.DataFrame: ê²°í•©ëœ ì°¨íŠ¸ ë°ì´í„°
        """
        try:
            with self._lock:
                if stock_code not in self.selected_stocks:
                    return None
                    
                stock_data = self.selected_stocks[stock_code]
                historical_data = stock_data.historical_data.copy()
                realtime_data = stock_data.realtime_data.copy()
            
            # ë‘ ë°ì´í„° ê²°í•©
            if historical_data.empty and realtime_data.empty:
                return pd.DataFrame()
            elif historical_data.empty:
                combined_data = realtime_data
            elif realtime_data.empty:
                combined_data = historical_data
            else:
                combined_data = pd.concat([historical_data, realtime_data], ignore_index=True)
            
            # ì‹œê°„ìˆœ ì •ë ¬
            if 'datetime' in combined_data.columns:
                combined_data = combined_data.sort_values('datetime').reset_index(drop=True)
            elif 'date' in combined_data.columns and 'time' in combined_data.columns:
                combined_data = combined_data.sort_values(['date', 'time']).reset_index(drop=True)
            
            return combined_data
            
        except Exception as e:
            self.logger.error(f"âŒ {stock_code} ê²°í•© ì°¨íŠ¸ ë°ì´í„° ìƒì„± ì˜¤ë¥˜: {e}")
            return None
    
    def get_stock_analysis(self, stock_code: str) -> Optional[Dict[str, Any]]:
        """
        ì¢…ëª© ë¶„ì„ ì •ë³´ ì¡°íšŒ
        
        Args:
            stock_code: ì¢…ëª©ì½”ë“œ
            
        Returns:
            Dict: ë¶„ì„ ì •ë³´
        """
        try:
            combined_data = self.get_combined_chart_data(stock_code)
            
            if combined_data is None or combined_data.empty:
                return None
            
            with self._lock:
                if stock_code not in self.selected_stocks:
                    return None
                    
                stock_data = self.selected_stocks[stock_code]
            
            # ê¸°ë³¸ ì •ë³´
            analysis = {
                'stock_code': stock_code,
                'stock_name': stock_data.stock_name,
                'selected_time': stock_data.selected_time,
                'data_complete': stock_data.data_complete,
                'last_update': stock_data.last_update,
                'total_minutes': len(combined_data),
                'historical_minutes': len(stock_data.historical_data),
                'realtime_minutes': len(stock_data.realtime_data)
            }
            
            # ê°€ê²© ë¶„ì„ (close ì»¬ëŸ¼ì´ ìˆëŠ” ê²½ìš°)
            if 'close' in combined_data.columns and len(combined_data) > 0:
                prices = combined_data['close']
                
                analysis.update({
                    'first_price': float(prices.iloc[0]) if len(prices) > 0 else 0,
                    'current_price': float(prices.iloc[-1]) if len(prices) > 0 else 0,
                    'high_price': float(prices.max()),
                    'low_price': float(prices.min()),
                    'price_change': float(prices.iloc[-1] - prices.iloc[0]) if len(prices) > 1 else 0,
                    'price_change_rate': float((prices.iloc[-1] - prices.iloc[0]) / prices.iloc[0] * 100) if len(prices) > 1 and prices.iloc[0] > 0 else 0
                })
            
            # ê±°ë˜ëŸ‰ ë¶„ì„ (volume ì»¬ëŸ¼ì´ ìˆëŠ” ê²½ìš°)
            if 'volume' in combined_data.columns:
                volumes = combined_data['volume']
                analysis.update({
                    'total_volume': int(volumes.sum()),
                    'avg_volume': int(volumes.mean()) if len(volumes) > 0 else 0,
                    'max_volume': int(volumes.max()) if len(volumes) > 0 else 0
                })
            
            return analysis
            
        except Exception as e:
            self.logger.error(f"âŒ {stock_code} ë¶„ì„ ì •ë³´ ìƒì„± ì˜¤ë¥˜: {e}")
            return None
    
    def get_all_stocks_summary(self) -> Dict[str, Any]:
        """
        ëª¨ë“  ê´€ë¦¬ ì¢…ëª© ìš”ì•½ ì •ë³´
        
        Returns:
            Dict: ì „ì²´ ìš”ì•½ ì •ë³´
        """
        try:
            with self._lock:
                stock_codes = list(self.selected_stocks.keys())
            
            summary = {
                'total_stocks': len(stock_codes),
                'max_stocks': self.max_stocks,
                'current_time': now_kst().strftime('%Y-%m-%d %H:%M:%S'),
                'stocks': []
            }
            
            for stock_code in stock_codes:
                analysis = self.get_stock_analysis(stock_code)
                if analysis:
                    summary['stocks'].append({
                        'stock_code': stock_code,
                        'stock_name': analysis['stock_name'],
                        'selected_time': analysis['selected_time'].strftime('%H:%M:%S'),
                        'data_complete': analysis['data_complete'],
                        'total_minutes': analysis['total_minutes'],
                        'price_change_rate': analysis.get('price_change_rate', 0)
                    })
            
            return summary
            
        except Exception as e:
            self.logger.error(f"âŒ ì „ì²´ ìš”ì•½ ì •ë³´ ìƒì„± ì˜¤ë¥˜: {e}")
            return {}
    
    def remove_stock(self, stock_code: str) -> bool:
        """
        ì¢…ëª© ì œê±°
        
        Args:
            stock_code: ì¢…ëª©ì½”ë“œ
            
        Returns:
            bool: ì œê±° ì„±ê³µ ì—¬ë¶€
        """
        try:
            with self._lock:
                if stock_code in self.selected_stocks:
                    stock_name = self.selected_stocks[stock_code].stock_name
                    del self.selected_stocks[stock_code]
                    self.logger.info(f"ğŸ—‘ï¸ {stock_code}({stock_name}) ê´€ë¦¬ ëª©ë¡ì—ì„œ ì œê±°")
                    return True
                else:
                    return False
                    
        except Exception as e:
            self.logger.error(f"âŒ {stock_code} ì œê±° ì˜¤ë¥˜: {e}")
            return False
    

    
    async def batch_update_realtime_data(self):
        """
        ëª¨ë“  ê´€ë¦¬ ì¢…ëª©ì˜ ì‹¤ì‹œê°„ ë°ì´í„° ì¼ê´„ ì—…ë°ì´íŠ¸ (1ë¶„ë§ˆë‹¤)
        """
        try:
            with self._lock:
                stock_codes = list(self.selected_stocks.keys())
            
            if not stock_codes:
                return
            
            # ë™ì‹œ ì—…ë°ì´íŠ¸ (ë°°ì¹˜ í¬ê¸° ì¦ê°€ë¡œ íš¨ìœ¨ì„± í–¥ìƒ)
            batch_size = 20  # ë°°ì¹˜ í¬ê¸° ì¦ê°€
            for i in range(0, len(stock_codes), batch_size):
                batch = stock_codes[i:i + batch_size]
                tasks = [self.update_realtime_data(code) for code in batch]
                await asyncio.gather(*tasks, return_exceptions=True)
                
                # API í˜¸ì¶œ ê°„ê²© ì¡°ì ˆ (ë” ë¹ ë¥¸ ì—…ë°ì´íŠ¸)
                if i + batch_size < len(stock_codes):
                    await asyncio.sleep(0.2)  # ê°„ê²© ë‹¨ì¶•
            
        except Exception as e:
            self.logger.error(f"âŒ ì‹¤ì‹œê°„ ë°ì´í„° ì¼ê´„ ì—…ë°ì´íŠ¸ ì˜¤ë¥˜: {e}")